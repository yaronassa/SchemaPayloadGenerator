<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>schema-payload-generator</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">schema-payload-generator</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> schema-payload-generator</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<h1 id="schema-payload-generator">Schema Payload Generator</h1>
				<p><a href="https://travis-ci.org/yaronassa/SchemaPayloadGenerator"><img src="https://travis-ci.org/yaronassa/SchemaPayloadGenerator.svg?branch=master" alt="Build Status"></a>
				<a href="https://coveralls.io/github/yaronassa/SchemaPayloadGenerator?branch=master"><img src="https://coveralls.io/repos/github/yaronassa/SchemaPayloadGenerator/badge.svg?branch=master" alt="Coverage Status"></a></p>
				<p>Schema payload generator allows you to generate all* possible payload combination for objects in your schema.
				You can use these payloads for unit/api tests, examples, etc.</p>
				<p>(* Well, obviously not <em>ALL</em> possibilities, but multiple values per field, with cumulative combinations for arrays and objects)</p>
				<p>Working with ProtoBuff? FastBuffers? XML schemas? Just convert them to JSONSchema and you&#39;re good to go</p>
				<h2 id="tl-dr">TL;DR</h2>
				<p><strong>Install</strong></p>
				<pre><code class="language-shell"><span class="hljs-meta">$</span><span class="bash"> npm install schema-payload-generator</span></code></pre>
				<p><strong>Generate payloads</strong></p>
				<pre><code class="language-javascript"><span class="hljs-keyword">import</span> {SchemaPayloadGenerator} <span class="hljs-keyword">from</span> <span class="hljs-string">'schema-payload-generator'</span>
<span class="hljs-keyword">const</span> generator = <span class="hljs-keyword">new</span> SchemaPayloadGenerator();
<span class="hljs-keyword">await</span> generator.loadSchema(mySchemaPathOrObject);
<span class="hljs-keyword">const</span> possibilities = <span class="hljs-keyword">await</span> generator.generatePayloads();</code></pre>
				<p><strong>Test/Use</strong></p>
				<pre><code class="language-javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`TEST ALL THE THINGS!`</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> possibility <span class="hljs-keyword">of</span> possibilities) {
    <span class="hljs-keyword">await</span> myAPIClient.get(possibility.payload);
}</code></pre>
				<h2 id="documentation">Documentation</h2>
				<p>Project code documentation is available at the <a href="https://yaronassa.github.io/SchemaPayloadGenerator/">github page</a>.</p>
				<h2 id="out-of-the-box-usage">Out-Of-The-Box usage</h2>
				<h3 id="loading-a-schema">Loading a schema</h3>
				<p>Using schema payload generator always starts with loading a quasi-valid schema object. It doesn&#39;t have to be a full-blown by-the-book schema (though it can be) - even fragements lik e <code>{type: &#39;boolean&#39;}</code> can work.</p>
				<p><strong>Please note</strong> Like the value generation itself, the <a href="https://yaronassa.github.io/SchemaPayloadGenerator/classes/schemapayloadgenerator.html#loadschema"><code>.loadSchema</code></a> command is asynchronous and returns a <code>Promise</code>.</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">import</span> {SchemaPayloadGenerator} <span class="hljs-keyword">from</span> <span class="hljs-string">'schema-payload-generator'</span>
<span class="hljs-keyword">const</span> generator = <span class="hljs-keyword">new</span> SchemaPayloadGenerator();
<span class="hljs-keyword">await</span> generator.loadSchema({<span class="hljs-attr">type</span>: <span class="hljs-string">'object'</span>, <span class="hljs-attr">properties</span>: {<span class="hljs-attr">myBool</span>: {<span class="hljs-attr">type</span>: <span class="hljs-string">'boolean}}});</span></code></pre>
				<p>Alternatively You can send a relative path to a an external file that will be required.</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">await</span> generator.loadSchema(<span class="hljs-string">'./pathToFile.json'</span>);</code></pre>
				<p>The schema will be parsed by <a href="https://www.npmjs.com/package/json-schema-ref-parser">JSON Schema $Ref Parser</a>, and can receive an <a href="https://github.com/APIDevTools/json-schema-ref-parser/blob/master/docs/options.md">options object</a> that will be passed directly to the parser.</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">await</span> generator.loadSchema(<span class="hljs-string">'./pathToFile.json'</span>, {<span class="hljs-attr">dereference</span>: {<span class="hljs-attr">circular</span>: <span class="hljs-literal">false</span>}});</code></pre>
				<p>The parser will resolve all local / remote references, $ref values, etc, so you don&#39;t need to prepare / change your schemas.</p>
				<h3 id="generating-values">Generating values</h3>
				<p><strong>Please note</strong> Like the schema loading operations, the <a href="https://yaronassa.github.io/SchemaPayloadGenerator/classes/schemapayloadgenerator.html#generatepayloads"><code>.generatePayloads</code></a> command is asynchronous and returns a <code>Promise</code>. </p>
				<p>Once a schema is loaded, generating values is straightforward:</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> possibilities = <span class="hljs-keyword">await</span> generator.generatePayloads();

<span class="hljs-comment">/*
* possibilities is an array of IFieldPossiblePayload:
* {
*   field: JSON6Schema     // The original schema field
*   payload: any         // The actual generated payload to be used
*   parentPossiblePayload?: IFieldPossiblePayload // The base-payload this one extends
* }
*/</span></code></pre>
				<p>In case the loaded schema contains many definitions and no main object (usually the case for API specs), you&#39;ll need to pass the relevant definition key.</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> possibilities = <span class="hljs-keyword">await</span> generator.generatePayloads(<span class="hljs-string">'key_under_definitions_schema_node'</span>);</code></pre>
				<h4 id="default-generated-values">Default generated values</h4>
				<p>By default, the generator will generate value possibilities according to the object types (read about <a href="#customising-value-generation">more flexible customizations</a> below).</p>
				<p>The values generated by default are:</p>
				<table>
					<thead>
						<tr>
							<th>Type</th>
							<th>Generated Values</th>
							<th>Remarks</th>
						</tr>
					</thead>
					<tbody><tr>
							<td>Boolean</td>
							<td><code>[true, false]</code></td>
							<td></td>
						</tr>
						<tr>
							<td>Integer</td>
							<td><code>[min, max, between]</code></td>
							<td>Min = as set by minimum. Defaults to 1. <br/> Max = as set by maximum. Defaults to 100. <br/> Between = a random number between min and max.</td>
						</tr>
						<tr>
							<td>Number</td>
							<td><code>[min, max, between]</code></td>
							<td>Treated as Integer</td>
						</tr>
						<tr>
							<td>String</td>
							<td><code>[&quot;Value&quot;]</code></td>
							<td>Actual value produced by <a href="json-schema-faker">https://github.com/json-schema-faker/json-schema-faker</a></td>
						</tr>
						<tr>
							<td>Field w/ enum</td>
							<td><code>[enum value, enum value]</code></td>
							<td>The returned array includes all values</td>
						</tr>
						<tr>
							<td>Array</td>
							<td><code>[[values], [values]]</code></td>
							<td>The values are all of the array&#39;s inner type value possibilities as well as all their <a href="https://en.wikipedia.org/wiki/All-pairs_testing">pairwise combinations</a></td>
						</tr>
						<tr>
							<td>Object</td>
							<td><code>[{payload:1}, {payload:2}]</code></td>
							<td>All the possibles payload combinations according to the object&#39;s <code>.properties</code> and <code>.required</code> properties</td>
						</tr>
				</tbody></table>
				<p>At the end, the value-generations is always done for a root Object type field (The schema / one of its definitions). All the &quot;leafs&quot; fields are flattened out to JSON payloads, and so on until an array of root-level JSON payloads is returned.</p>
				<p>These default values can be manipulated and overriden, as explained below.</p>
				<h4 id="limiting-variations">Limiting variations</h4>
				<p>For simple schemas, the TD;LR version is enough. You load the schema, produce ~100 or so payload variations, and go on with your business.</p>
				<p>For complex schemas, however, the variation count will exponentially &quot;exlode&quot; and become unusable. Even a seemingly simple schema with a few well place <code>$ref</code> pointers can explode into many millions / billions of variations. Usually node will break before you do, but even if node doesn&#39;t crash on an out-of-memory error, that much data (and the runtime needed to produce it) will prove unusable.</p>
				<p>So, you&#39;ll have to limit the generated variations in some manner. This can be done through three mechanisms.</p>
				<ul>
					<li>Override the value-generation for some of the types (e.g., make enum fields return only some of the variations).</li>
					<li>Create other mechanisms to generate specific values, or even surpress value generation altogether (e.g. do no produce values for fields in a given object path / with a specific title)</li>
					<li>Tweak the way value-combinations are generated (e.g. instead of creating a full pairwise array for big enums, take maximum 5 pair-combinations).</li>
				</ul>
				<p>All these are covered in the following section <a href="#customising-value-generation">Customising value generation</a>.</p>
				<h2 id="customising-value-generation">Customising value generation</h2>
				<h3 id="value-combination-tweaks">Value combination tweaks</h3>
				<p>There are several field types that are responsible for combining values and generating massive amounts of these combinations. Specifically, array-type and object-type fields &quot;explode&quot; their inner-fields variations into multiple combinations. By tweaking these combination tweaks, you can significantly reduce the number of produce value variations.</p>
				<h4 id="arrays">Arrays</h4>
				<p>The default processing for an array field is to include each of its sub-field possible values, as well as every non-repeating-pair-combination between these values. So the schema field <code>{type: &#39;array&#39;, items: {type: &#39;boolean&#39;}}</code> will produce these possible sub-field values: <code>[true, false]</code>. These will be exploded into the array possibilities of <code>[[true], [false], [true, false]]</code>. Every value is included once, then every value pair.</p>
				<p>This may not seem that bad, but imagine an array of an enum field with 8 possible values. The array possible values count will be 8 original values + 7 pairs for the 1st value + 6 for the 2nd + ... + 1 pair for the 7th = <strong>total of 36 value combinations</strong>.</p>
				<p>You can control and limit the way these variations are generated via the <code>combinations.arrays</code> field in the generator options.</p>
				<p><strong>maxCombinations</strong>:</p>
				<p>Set <code>arrays.maxCombinations</code> to an integer to crudly truncate the array possible values. The remaining values may or may not include the original single-values, dependent on how much was trunced. </p>
				<p><strong>combinationGenerator</strong>:</p>
				<p>For even more control, set this option to your custom function, and generate the value combinations yourself. Returning an undefined result will fallback to the default behaviour:</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> customCombinationGenerator = (field: IFieldProcessingData, <span class="hljs-attr">subFieldRawValues</span>: any[]): any[][] =&gt; {
   <span class="hljs-comment">// Return your values here.</span>
   <span class="hljs-comment">// Remember, it should be an array of arrays</span>
   <span class="hljs-comment">// For example</span>
   <span class="hljs-keyword">return</span> subFieldRawValues.reverse().map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> [item]);
};</code></pre>
				<h4 id="objects">Objects</h4>
				<p>The default processing for an object field is to get all possible variations for all property fields, than build every possible variation combination between all the properties (non-mandatory properties are added an <code>undefined</code> possible value for the combination matrix).</p>
				<p>Understandably, this process creates <strong>huge</strong> amounts of payload variations. An object field with 5 properties can easily have a few hundred payload variations, a few thousands if some of those are array properties. Given this, the limit mechanisms for object combinations are more substantial.</p>
				<p><strong>maxPropertyCombinations</strong>:</p>
				<p>Set <code>objects.maxPropertyCombinations</code> to an integer to crudly truncate each object property possible values, before they are combined in the object payloads. This does <strong>not</strong> affect non-mandatory fields gaining the additional <code>undefined</code> option.</p>
				<p>e.g. if an object has a boolean property, setting <code>maxPropertyCombinations</code> to 1, will cause the boolean property to contribute only 1 possibility to the payload combinations matrix (compared to the 2 it usually does). The total payload count for that object may still be very high.</p>
				<p><strong>maxObjectPayloadCombinations</strong>:</p>
				<p>Set <code>objects.maxObjectPayloadCombinations</code> to an integer to crudly truncate the object&#39;s generated payloads count.</p>
				<p>e.g. if an object have a boolean property and a string property, setting <code>maxObjectPayloadCombinations</code> to 1, will cause the object to have only 1 possible payload (compared to the 6 - <em>2 + undefined for the boolean X 1 + undefined for the string</em>) it usually does).</p>
				<p><strong>minimalPayloadCombinationGenerator</strong>:</p>
				<p>For even more control, set this option to your custom function, and generate the value combinations yourself. This function is responsible for generating the minimial payloads, i.e. payloads that contain all the required fields. Returning an undefined result will fallback to the default behaviour:</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> customMinimalPayloadCombinationGenerator = (objectField: IFieldProcessingData, <span class="hljs-attr">requiredPropertiesPossibilities</span>: {[key: string]: IFieldPossiblePayload[]}): any[] =&gt; {
   <span class="hljs-comment">// Return your payloads here.</span>
   <span class="hljs-comment">// Remember, EVERY payload MUST include all properties (they are required)</span>
   <span class="hljs-comment">// For example - return 1 payload with the 1st possibility from each property</span>

   <span class="hljs-keyword">const</span> payload = {};
   <span class="hljs-built_in">Object</span>.keys(requiredPropertiesPossibilities).forEach(<span class="hljs-function"><span class="hljs-params">propertyKey</span> =&gt;</span> {
       payload[propertyKey] = requiredPropertiesPossibilities[propertyKey][<span class="hljs-number">0</span>].payload;
   });

   <span class="hljs-keyword">return</span> [payload];
};</code></pre>
				<p><strong>optionalPayloadCombinationsGenerator</strong>:
					This function is responsible for enriching each minimal payload with non-mandatory fields.
					Each payload this funciton returns will be combined with <strong>all</strong> the minimal payloads. So if the function returns 3 payload possibilities for the optional fields, and there are 2 minimal payload possibilities, we&#39;ll get a total of 2X4 (3 + undefined)=8 payload possibilities.
				Returning an undefined result will fallback to the default behaviour.</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> customOptionalPayloadCombinationGenerator = (field: IFieldProcessingData, <span class="hljs-attr">generatedMinimalPayloads</span>: IFieldPossiblePayload[], <span class="hljs-attr">optionalPropertiesPossibilities</span>: {[key: string]: IFieldPossiblePayload[]}): any[] =&gt; {
   <span class="hljs-comment">// Return your payloads here.</span>
   <span class="hljs-comment">// No need to return the undefined payload - it will be added automatically</span>
   <span class="hljs-comment">// For example - return 1 payload with the 1st possibility from each property</span>

   <span class="hljs-keyword">const</span> payload = {};
   <span class="hljs-built_in">Object</span>.keys(optionalPropertiesPossibilities).forEach(<span class="hljs-function"><span class="hljs-params">propertyKey</span> =&gt;</span> {
       payload[propertyKey] = optionalPropertiesPossibilities[propertyKey][<span class="hljs-number">0</span>].payload;
   });

   <span class="hljs-keyword">return</span> [payload];
};</code></pre>
				<h3 id="custom-type-specific-generators">Custom type-specific generators</h3>
				<p>This mechanism allows you to quickluy generate your own values for a specific schema type, via the <code>customTypeProcessors</code> field of the generator options object. For example, you might want to generate URIs in a given domain for a string URI value, or to always output the title of the field as its value. Just prepare a function that recieves the field schema object, and returns a promise that resolves to an array of raw-values, and you&#39;re good to go.</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> newStringProcessor = <span class="hljs-keyword">async</span> (fieldSchema) =&gt; fieldSchema.title;
<span class="hljs-keyword">const</span> generator = <span class="hljs-keyword">new</span> SchemaPayloadGenerator({<span class="hljs-attr">options</span>: {<span class="hljs-attr">customTypeProcessors</span>: {<span class="hljs-attr">string</span>: newStringProcessor}}});
<span class="hljs-keyword">await</span> generator.loadSchema({<span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'myTitle'</span>});
<span class="hljs-keyword">const</span> payloads = <span class="hljs-keyword">await</span> generator.generatePayloads();

<span class="hljs-built_in">console</span>.log(payloads[<span class="hljs-number">0</span>].payload); <span class="hljs-comment">// output = 'myTitle'</span></code></pre>
				<p>(of course you can have many type processors for any possible type).</p>
				<p>The entire value generation mechansim is asynchronous to allow for complex customizations (you can query a DB / API to generate values, have your own caches and enums, etc.).</p>
				<h3 id="custom-general-generators">Custom general generators</h3>
				<p>Customizing the value generation for specific types is great, but you may want to control the value generation in a more nuanced manner. This requires a broader context, as well as the ability to inspect a field, without commiting to change its values beforehand.</p>
				<p>This can be achieved via the <code>customFieldProcessors</code> field of the generator options object. This field can be set to an array of custom processing functions, that will each be called in order. Each function can inspect the field and its context, and either return the values for the field, or <code>undefined</code>. If a function doesn&#39;t return values, the next funciton in line is called. If all custom functions are exausted, the generator will continue its regular generating process (including calling custom type-specific funciton, etc.).</p>
				<p>These functions get a much broader context than the type-specific custom function:</p>
				<pre><code class="language-typescript">(field: IFieldProcessingData, entireSchema: JSONSchema6, processorClass: CustomFieldProcessor) =&gt; <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">any</span>[]&gt;;</code></pre>
				<p>Where the <code>field</code> parameter include the field&#39;s schema, parent, key name in parent and its full path; and the <code>processorClass</code> parameter is the <code>CustomFieldProcessor</code> class, which allows access to the generator, options, and other utility functions.</p>
				<p><strong>For example</strong>: </p>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> disallowFields = <span class="hljs-keyword">async</span> (field, entireSchema, processorClass) =&gt; {
    <span class="hljs-keyword">if</span> (field.fieldFullPath === <span class="hljs-string">'/some/property/path'</span>) <span class="hljs-keyword">return</span> [];
    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^disallowedPrefix/i</span>.test(field.schema.title)) <span class="hljs-keyword">return</span> [];
}

<span class="hljs-keyword">const</span> allowSpecificField = <span class="hljs-keyword">async</span> (field, entireSchema, processorClass) =&gt; {
    <span class="hljs-keyword">if</span> (field.schema.title === <span class="hljs-string">'disallowedPrefix but include this one'</span>) <span class="hljs-keyword">return</span> [<span class="hljs-string">'A value'</span>];
}
<span class="hljs-keyword">const</span> generator = <span class="hljs-keyword">new</span> SchemaPayloadGenerator({<span class="hljs-attr">customFieldProcessors</span>: [disallowFields, allowSpecificField]});
<span class="hljs-keyword">await</span> generator.loadSchema({<span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'disallowedPrefix but include this one'</span>});
<span class="hljs-keyword">let</span> payloads = <span class="hljs-keyword">await</span> generator.generatePayloads();

<span class="hljs-built_in">console</span>.log(payloads[<span class="hljs-number">0</span>].payload); <span class="hljs-comment">// output = 'A value'</span>

<span class="hljs-keyword">await</span> generator.loadSchema({<span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'disallowedPrefix'</span>});
payloads = <span class="hljs-keyword">await</span> generator.generatePayloads();

<span class="hljs-built_in">console</span>.log(payloads.length); <span class="hljs-comment">// output = 0</span>

<span class="hljs-keyword">await</span> generator.loadSchema({<span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'Other title'</span>});
payloads = <span class="hljs-keyword">await</span> generator.generatePayloads();

<span class="hljs-built_in">console</span>.log(payloads[<span class="hljs-number">0</span>].payload); <span class="hljs-comment">// output = regular random output for a string value</span>
</code></pre>
				<p>The custom processors are executed in reverse order, so once <code>allowSpecificField</code>catches field in the 1st generation, it returns the payload <code>[&#39;A value&#39;]</code>.
					In the 2nd generation, the field slips by, and is caught by <code>disallowFields</code>, and 0 payloads are returned.
				Any other field will have these functions return <code>undefined</code>, and the payloads will be generated as usual.</p>
				<h2 id="further-customizations">Further customizations</h2>
				<p>Schema payload generator was built with user-customization in mind. Beside the build-in customization mechanisms described above, all the classes were build to be inherited and extended.</p>
				<p>You&#39;ll find that all of the inner properties and methods that&#39;re relevant to value generation and field processing are <code>protected</code> (rather than <code>private</code>), to facilitate extending the class and overriding its members.</p>
				<p>Similaraly, the field processing classes extend a base class, which can be extended to achieve new functionality.</p>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
					<li class=" tsd-kind-class tsd-is-not-exported">
						<a href="classes/basefieldprocessor.html" class="tsd-kind-icon">Base<wbr>Field<wbr>Processor</a>
					</li>
					<li class=" tsd-kind-class tsd-is-not-exported">
						<a href="classes/customfieldprocessor.html" class="tsd-kind-icon">Custom<wbr>Field<wbr>Processor</a>
					</li>
					<li class=" tsd-kind-class tsd-is-not-exported">
						<a href="classes/schemapayloadgenerator.html" class="tsd-kind-icon">Schema<wbr>Payload<wbr>Generator</a>
					</li>
					<li class=" tsd-kind-class tsd-is-not-exported">
						<a href="classes/typefieldprocessor.html" class="tsd-kind-icon">Type<wbr>Field<wbr>Processor</a>
					</li>
					<li class=" tsd-kind-interface tsd-is-not-exported">
						<a href="interfaces/ifieldpossiblepayload.html" class="tsd-kind-icon">IField<wbr>Possible<wbr>Payload</a>
					</li>
					<li class=" tsd-kind-interface tsd-is-not-exported">
						<a href="interfaces/ifieldprocessingdata.html" class="tsd-kind-icon">IField<wbr>Processing<wbr>Data</a>
					</li>
					<li class=" tsd-kind-interface tsd-is-not-exported">
						<a href="interfaces/ischemapayloadgeneratoroptions.html" class="tsd-kind-icon">ISchema<wbr>Payload<wbr>Generator<wbr>Options</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-is-not-exported">
						<a href="globals.html#customprocessorfunction" class="tsd-kind-icon">Custom<wbr>Processor<wbr>Function</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-is-not-exported">
						<a href="globals.html#typehandler" class="tsd-kind-icon">Type<wbr>Handler</a>
					</li>
					<li class=" tsd-kind-variable tsd-is-not-exported">
						<a href="globals.html#assigndeep" class="tsd-kind-icon">assign<wbr>Deep</a>
					</li>
					<li class=" tsd-kind-variable tsd-is-not-exported">
						<a href="globals.html#bluebird" class="tsd-kind-icon">bluebird</a>
					</li>
					<li class=" tsd-kind-variable tsd-is-not-exported">
						<a href="globals.html#jsf" class="tsd-kind-icon">jsf</a>
					</li>
					<li class=" tsd-kind-variable tsd-is-not-exported">
						<a href="globals.html#path" class="tsd-kind-icon">path</a>
					</li>
					<li class=" tsd-kind-variable tsd-is-not-exported">
						<a href="globals.html#refparser" class="tsd-kind-icon">ref<wbr>Parser</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>