<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>schema-payload-generator</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">schema-payload-generator</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> schema-payload-generator</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<h1 id="schema-payload-generator">Schema Payload Generator</h1>
				<p><a href="https://travis-ci.org/%3Cusername%3E/%3Creponame%3E"><img src="https://travis-ci.org/<username>/<reponame>.svg?branch=master" alt="Build Status"></a>
				<a href="https://coveralls.io/github/%3Cusername%3E/%3Creponame%3E?branch=master"><img src="https://coveralls.io/repos/github/<username>/<reponame>/badge.svg?branch=master" alt="Coverage Status"></a></p>
				<p>Schema payload generator allows you to generate all* possible payload combination for objects in your schema.
				You can use these payloads for unit/api tests, examples, etc.</p>
				<p>(* Well, obviously not <em>ALL</em> possibilities, but multiple values per field, with cumulative combinations for arrays and objects)</p>
				<p>Working with ProtoBuff? FastBuffers? XML schemas? Just convert them to JSONSchema and you&#39;re good to go</p>
				<h2 id="tl-dr">TL;DR</h2>
				<p><strong>Install</strong></p>
				<pre><code class="language-shell"><span class="hljs-meta">$</span><span class="bash"> npm install schema-payload-generator</span></code></pre>
				<p><strong>Generate payloads</strong></p>
				<pre><code class="language-javascript"><span class="hljs-keyword">import</span> {SchemaPayloadGenerator} <span class="hljs-keyword">from</span> <span class="hljs-string">'schema-payload-generator'</span>
<span class="hljs-keyword">const</span> generator = <span class="hljs-keyword">new</span> SchemaPayloadGenerator();
<span class="hljs-keyword">await</span> generator.loadSchema(mySchemaPathOrObject);
<span class="hljs-keyword">const</span> possibilities = <span class="hljs-keyword">await</span> generator.generatePayloads();</code></pre>
				<p><strong>Test/Use</strong></p>
				<pre><code class="language-javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`TEST ALL THE THINGS!`</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> possibility <span class="hljs-keyword">of</span> possibilities) {
    <span class="hljs-keyword">await</span> myAPIClient.get(possibility.payload);
}</code></pre>
				<h2 id="documentation">Documentation</h2>
				<h2 id="out-of-the-box-usage">Out-Of-The-Box usage</h2>
				<h3 id="loading-a-schema">Loading a schema</h3>
				<p>Using schema payload generator always starts with loading a quasi-valid schema object. It doesn&#39;t have to be a full-blown by-the-book schema (though it can be) - even fragements lik e <code>{type: &#39;boolean&#39;}</code> can work.</p>
				<p><strong>Please note</strong> Like the value generation itself, the <code>.loadSchema</code> command is asynchronous and returns a <code>Promise</code>.</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">import</span> {SchemaPayloadGenerator} <span class="hljs-keyword">from</span> <span class="hljs-string">'schema-payload-generator'</span>
<span class="hljs-keyword">const</span> generator = <span class="hljs-keyword">new</span> SchemaPayloadGenerator();
<span class="hljs-keyword">await</span> generator.loadSchema({<span class="hljs-attr">type</span>: <span class="hljs-string">'object'</span>, <span class="hljs-attr">properties</span>: {<span class="hljs-attr">myBool</span>: {<span class="hljs-attr">type</span>: <span class="hljs-string">'boolean}}});</span></code></pre>
				<p>Alternatively You can send a relative path to a an external file that will be required.</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">await</span> generator.loadSchema(<span class="hljs-string">'./pathToFile.json'</span>);</code></pre>
				<p>The schema will be parsed by <a href="https://www.npmjs.com/package/json-schema-ref-parser">JSON Schema $Ref Parser</a>, and can receive an <a href="https://github.com/APIDevTools/json-schema-ref-parser/blob/master/docs/options.md">options object</a> that will be passed directly to the parser.</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">await</span> generator.loadSchema(<span class="hljs-string">'./pathToFile.json'</span>, {<span class="hljs-attr">dereference</span>: {<span class="hljs-attr">circular</span>: <span class="hljs-literal">false</span>}});</code></pre>
				<p>The parser will resolve all local / remote references, $ref values, etc, so you don&#39;t need to prepare / change your schemas.</p>
				<h3 id="generating-values">Generating values</h3>
				<p><strong>Please note</strong> Like the schema loading operations, the <code>generator.generatePayloads</code> command is asynchronous and returns a <code>Promise</code>. </p>
				<p>Once a schema is loaded, generating values is straightforward:</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> possibilities = <span class="hljs-keyword">await</span> generator.generatePayloads();

<span class="hljs-comment">/*
* possibilities is an array of IFieldPossiblePayload:
* {
*   field: JSON6Schema     // The original schema field
*   payload: any         // The actual generated payload to be used
*   parentPossiblePayload?: IFieldPossiblePayload // The base-payload this one extends
* }
*/</span></code></pre>
				<p>In case the loaded schema contains many definitions and no main object (usually the case for API specs), you&#39;ll need to pass the relevant definition key.</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> possibilities = <span class="hljs-keyword">await</span> generator.generatePayloads(<span class="hljs-string">'key_under_definitions_schema_node'</span>);</code></pre>
				<h4 id="default-generated-values">Default generated values</h4>
				<p>By default, the generator will generate value possibilities according to the object types (read about <a href="#customising-value-generation">more flexible customizations</a> below).</p>
				<p>The values generated by default are:</p>
				<table>
					<thead>
						<tr>
							<th>Type</th>
							<th>Generated Values</th>
							<th>Remarks</th>
						</tr>
					</thead>
					<tbody><tr>
							<td>Boolean</td>
							<td><code>[true, false]</code></td>
							<td></td>
						</tr>
						<tr>
							<td>Integer</td>
							<td><code>[min, max, between]</code></td>
							<td>Min = as set by minimum. Defaults to 1. <br/> Max = as set by maximum. Defaults to 100. <br/> Between = a random number between min and max.</td>
						</tr>
						<tr>
							<td>Number</td>
							<td><code>[min, max, between]</code></td>
							<td>Treated as Integer</td>
						</tr>
						<tr>
							<td>String</td>
							<td><code>[&quot;Value&quot;]</code></td>
							<td>Actual value produced by <a href="json-schema-faker">https://github.com/json-schema-faker/json-schema-faker</a></td>
						</tr>
						<tr>
							<td>Field w/ enum</td>
							<td><code>[enum value, enum value]</code></td>
							<td>The returned array includes all values</td>
						</tr>
						<tr>
							<td>Array</td>
							<td><code>[[values], [values]]</code></td>
							<td>The values are all of the array&#39;s inner type value possibilities as well as all their <a href="https://en.wikipedia.org/wiki/All-pairs_testing">pairwise combinations</a></td>
						</tr>
						<tr>
							<td>Object</td>
							<td><code>[{payload:1}, {payload:2}]</code></td>
							<td>All the possibles payload combinations according to the object&#39;s <code>.properties</code> and <code>.required</code> properties</td>
						</tr>
				</tbody></table>
				<p>At the end, the value-generations is always done for a root Object type field (The schema / one of its definitions). All the &quot;leafs&quot; fields are flattened out to JSON payloads, and so on until an array of root-level JSON payloads is returned.</p>
				<p>These default values can be manipulated and overriden, as explained below.</p>
				<h4 id="limiting-variations">Limiting variations</h4>
				<p>For simple schemas, the TD;LR version is enough. You load the schema, produce ~100 or so payload variations, and go on with your business.</p>
				<p>For complex schemas, however, the variation count will exponentially &quot;exlode&quot; and become unusable. Even a seemingly simple schema with a few well place <code>$ref</code> pointers can explode into many millions / billions of variations. Usually node will break before you do, but even if node doesn&#39;t crash on an out-of-memory error, that much data (and the runtime needed to produce it) will prove unusable.</p>
				<p>So, you&#39;ll have to limit the generated variations in some manner. This can be done through three mechanisms.</p>
				<ul>
					<li>Override the value-generation for some of the types (e.g., make enum fields return only some of the variations).</li>
					<li>Create other mechanisms to generate specific values, or even surpress value generation altogether (e.g. do no produce values for fields in a given object path / with a specific title)</li>
					<li>Tweak the way value-combinations are generated (e.g. instead of creating a full pairwise array for big enums, take maximum 5 pair-combinations).</li>
				</ul>
				<p>All these are covered in the following section <a href="#customising-value-generation">Customising value generation</a>.</p>
				<h2 id="customising-value-generation">Customising value generation</h2>
				<h3 id="value-combination-tweaks">Value combination tweaks</h3>
				<h3 id="custom-type-specific-generators">Custom type-specific generators</h3>
				<p>This mechanism allows you to quickluy generate your own values for a specific schema type, via the <code>customTypeProcessors</code> field of the generator options object. For example, you might want to generate URIs in a given domain for a string URI value, or to always output the title of the field as its value. Just prepare a function that recieves the field schema object, and returns a promise that resolves to an array of raw-values, and you&#39;re good to go.</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> newStringProcessor = <span class="hljs-keyword">async</span> (fieldSchema) =&gt; fieldSchema.title;
<span class="hljs-keyword">const</span> generator = <span class="hljs-keyword">new</span> SchemaPayloadGenerator({<span class="hljs-attr">options</span>: {<span class="hljs-attr">customTypeProcessors</span>: {<span class="hljs-attr">string</span>: newStringProcessor}}});
<span class="hljs-keyword">await</span> generator.loadSchema({<span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'myTitle'</span>});
<span class="hljs-keyword">const</span> payloads = <span class="hljs-keyword">await</span> generator.generatePayloads();

<span class="hljs-built_in">console</span>.log(payloads[<span class="hljs-number">0</span>].payload); <span class="hljs-comment">// output = 'myTitle'</span></code></pre>
				<p>(of course you can have many type processors for any possible type).</p>
				<p>The entire value generation mechansim is asynchronous to allow for complex customizations (you can query a DB / API to generate values, have your own caches and enums, etc.).</p>
				<h3 id="custom-general-generators">Custom general generators</h3>
				<p>Customizing the value generation for specific types is great, but you may want to control the value generation in a more nuanced manner. This requires a broader context, as well as the ability to inspect a field, without commiting to change its values beforehand.</p>
				<p>This can be achieved via the <code>customFieldProcessors</code> field of the generator options object. This field can be set to an array of custom processing functions, that will each be called in order. Each function can inspect the field and its context, and either return the values for the field, or <code>undefined</code>. If a function doesn&#39;t return values, the next funciton in line is called. If all custom functions are exausted, the generator will continue its regular generating process (including calling custom type-specific funciton, etc.).</p>
				<p>These functions get a much broader context than the type-specific custom function:</p>
				<pre><code class="language-typescript">(field: IFieldProcessingData, entireSchema: JSONSchema6, processorClass: CustomFieldProcessor) =&gt; <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">any</span>[]&gt;;</code></pre>
				<p>Where the <code>field</code> parameter include the field&#39;s schema, parent, key name in parent and its full path; and the <code>processorClass</code> parameter is the <code>CustomFieldProcessor</code> class, which allows access to the generator, options, and other utility functions.</p>
				<p><strong>For example</strong>: </p>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> disallowFields = <span class="hljs-keyword">async</span> (field, entireSchema, processorClass) =&gt; {
    <span class="hljs-keyword">if</span> (field.fieldFullPath === <span class="hljs-string">'/some/property/path'</span>) <span class="hljs-keyword">return</span> [];
    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^disallowedPrefix/i</span>.test(field.schema.title)) <span class="hljs-keyword">return</span> [];
}

<span class="hljs-keyword">const</span> allowSpecificField = <span class="hljs-keyword">async</span> (field, entireSchema, processorClass) =&gt; {
    <span class="hljs-keyword">if</span> (field.schema.title === <span class="hljs-string">'disallowedPrefix but include this one'</span>) <span class="hljs-keyword">return</span> [<span class="hljs-string">'A value'</span>];
}
<span class="hljs-keyword">const</span> generator = <span class="hljs-keyword">new</span> SchemaPayloadGenerator({<span class="hljs-attr">customFieldProcessors</span>: [disallowFields, allowSpecificField]});
<span class="hljs-keyword">await</span> generator.loadSchema({<span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'disallowedPrefix but include this one'</span>});
<span class="hljs-keyword">let</span> payloads = <span class="hljs-keyword">await</span> generator.generatePayloads();

<span class="hljs-built_in">console</span>.log(payloads[<span class="hljs-number">0</span>].payload); <span class="hljs-comment">// output = 'A value'</span>

<span class="hljs-keyword">await</span> generator.loadSchema({<span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'disallowedPrefix'</span>});
payloads = <span class="hljs-keyword">await</span> generator.generatePayloads();

<span class="hljs-built_in">console</span>.log(payloads.length); <span class="hljs-comment">// output = 0</span>

<span class="hljs-keyword">await</span> generator.loadSchema({<span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'Other title'</span>});
payloads = <span class="hljs-keyword">await</span> generator.generatePayloads();

<span class="hljs-built_in">console</span>.log(payloads[<span class="hljs-number">0</span>].payload); <span class="hljs-comment">// output = regular random output for a string value</span>
</code></pre>
				<p>The custom processors are executed in reverse order, so once <code>allowSpecificField</code>catches field in the 1st generation, it returns the payload <code>[&#39;A value&#39;]</code>.
					In the 2nd generation, the field slips by, and is caught by <code>disallowFields</code>, and 0 payloads are returned.
				Any other field will have these functions return <code>undefined</code>, and the payloads will be generated as usual.</p>
				<h2 id="further-customizations">Further customizations</h2>
				<p>Schema payload generator was built with user-customization in mind. Beside the build-in customization mechanisms described above, all the classes were build to be inherited and extended.</p>
				<p>You&#39;ll find that all of the inner properties and methods that&#39;re relevant to value generation and field processing are <code>protected</code> (rather than <code>private</code>), to facilitate extending the class and overriding its members.</p>
				<p>Similaraly, the field processing classes extend a base class, which can be extended to achieve new functionality.</p>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
					<li class=" tsd-kind-class tsd-is-not-exported">
						<a href="classes/basefieldprocessor.html" class="tsd-kind-icon">Base<wbr>Field<wbr>Processor</a>
					</li>
					<li class=" tsd-kind-class tsd-is-not-exported">
						<a href="classes/customfieldprocessor.html" class="tsd-kind-icon">Custom<wbr>Field<wbr>Processor</a>
					</li>
					<li class=" tsd-kind-class tsd-is-not-exported">
						<a href="classes/schemapayloadgenerator.html" class="tsd-kind-icon">Schema<wbr>Payload<wbr>Generator</a>
					</li>
					<li class=" tsd-kind-class tsd-is-not-exported">
						<a href="classes/typefieldprocessor.html" class="tsd-kind-icon">Type<wbr>Field<wbr>Processor</a>
					</li>
					<li class=" tsd-kind-interface tsd-is-not-exported">
						<a href="interfaces/ifieldpossiblepayload.html" class="tsd-kind-icon">IField<wbr>Possible<wbr>Payload</a>
					</li>
					<li class=" tsd-kind-interface tsd-is-not-exported">
						<a href="interfaces/ifieldprocessingdata.html" class="tsd-kind-icon">IField<wbr>Processing<wbr>Data</a>
					</li>
					<li class=" tsd-kind-interface tsd-is-not-exported">
						<a href="interfaces/ischemapayloadgeneratoroptions.html" class="tsd-kind-icon">ISchema<wbr>Payload<wbr>Generator<wbr>Options</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-is-not-exported">
						<a href="globals.html#customprocessorfunction" class="tsd-kind-icon">Custom<wbr>Processor<wbr>Function</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-is-not-exported">
						<a href="globals.html#typehandler" class="tsd-kind-icon">Type<wbr>Handler</a>
					</li>
					<li class=" tsd-kind-variable tsd-is-not-exported">
						<a href="globals.html#assigndeep" class="tsd-kind-icon">assign<wbr>Deep</a>
					</li>
					<li class=" tsd-kind-variable tsd-is-not-exported">
						<a href="globals.html#bluebird" class="tsd-kind-icon">bluebird</a>
					</li>
					<li class=" tsd-kind-variable tsd-is-not-exported">
						<a href="globals.html#jsf" class="tsd-kind-icon">jsf</a>
					</li>
					<li class=" tsd-kind-variable tsd-is-not-exported">
						<a href="globals.html#path" class="tsd-kind-icon">path</a>
					</li>
					<li class=" tsd-kind-variable tsd-is-not-exported">
						<a href="globals.html#refparser" class="tsd-kind-icon">ref<wbr>Parser</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>